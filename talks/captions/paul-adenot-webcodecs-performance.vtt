WEBVTT

1
00:00:01.250 --> 00:00:02.083
<v ->Hi,</v>

2
00:00:02.083 --> 00:00:03.400
my name is Paul Adenot.

3
00:00:03.400 --> 00:00:05.860
I work at Mozilla on anything related to audio and video in

4
00:00:05.860 --> 00:00:07.280
Firefox.

5-p
00:00:07.280 --> 00:00:08.220
Today,

6
00:00:08.220 --> 00:00:11.530
I like to talk about a recent API called the WebCodecs API.

7
00:00:11.530 --> 00:00:13.740
And in particular about memory access patterns,

8
00:00:13.740 --> 00:00:16.670
when using this API in conjunction with other APIs on

9
00:00:16.670 --> 00:00:18.120
the web platform.

10
00:00:18.120 --> 00:00:20.230
We'll talk about some raw performance numbers

11
00:00:20.230 --> 00:00:22.090
when accessing video frames,

12
00:00:22.090 --> 00:00:24.100
what WebCodecs does today to minimize memory,

13
00:00:24.100 --> 00:00:25.310
access overhead

14
00:00:25.310 --> 00:00:27.940
and some problems that the API has today,

15
00:00:27.940 --> 00:00:30.910
where a solution exists, but hasn't been implemented.

16
00:00:30.910 --> 00:00:34.410
And more importantly about a couple of harder problems that

17
00:00:34.410 --> 00:00:35.680
we'll tackle in the future,

18
00:00:35.680 --> 00:00:38.150
so that using WebCodecs will have the same performance

19
00:00:38.150 --> 00:00:39.613
profile as a native app.

20-p
00:00:41.350 --> 00:00:42.650
Before starting.

21
00:00:42.650 --> 00:00:44.430
I like to say that any simple scenario,

22
00:00:44.430 --> 00:00:47.000
such as decoding and rendering video and audio

23
00:00:47.000 --> 00:00:48.650
are fairly optimized today,

24
00:00:48.650 --> 00:00:50.710
and we'll be talking about advanced use cases,

25
00:00:50.710 --> 00:00:51.900
such as big native apps

26
00:00:51.900 --> 00:00:55.333
compiled to WebAssembly that want to leverage WebCodecs

27
00:00:55.333 --> 00:00:58.690
to speed up their encoding and decoding operations

28
00:00:58.690 --> 00:00:59.720
or other programs

29
00:00:59.720 --> 00:01:02.310
that are making a rather intensive use WebCodecs

30
00:01:02.310 --> 00:01:04.693
and want to minimize any inefficiencies.

slide-2
00:01:06.270 --> 00:01:07.103
But first

32
00:01:07.103 --> 00:01:08.390
let me repeat an old quote

33
00:01:08.390 --> 00:01:10.810
often heard in the free software multimedia development

34
00:01:10.810 --> 00:01:11.930
circles:

35
00:01:11.930 --> 00:01:15.560
"memcpy is murder". Behind this tongue-in-cheek sentence

36
00:01:15.560 --> 00:01:18.860
lies in important fact: to maximize performance,

37
00:01:18.860 --> 00:01:21.670
the minimum of memory copies need to happen.

38
00:01:21.670 --> 00:01:24.740
And the working set of nap needs to be as small as possible

39
00:01:24.740 --> 00:01:27.433
to ideally git into CPU caches.

40
00:01:28.770 --> 00:01:30.800
Fetching memory into caches is slow,

41
00:01:30.800 --> 00:01:31.890
caches are small,

42
00:01:31.890 --> 00:01:33.540
so no duplications should happen.

slide-3
00:01:34.720 --> 00:01:38.040
But first let's consider the size of the problem.

44-p
00:01:38.040 --> 00:01:42.650
A video frame in YUV420, full HD, standard dynamic range

45
00:01:42.650 --> 00:01:44.113
is around 4MB.

46
00:01:44.950 --> 00:01:47.670
A video frame in YUV420, 4K,

47
00:01:47.670 --> 00:01:49.130
standard dynamic range

48
00:01:49.130 --> 00:01:50.553
is around 16MB.

49
00:01:51.430 --> 00:01:55.100
A video frame in P010, full HD, high dynamic range,

50
00:01:55.100 --> 00:01:58.753
(either 10 or 12 bits) is around 32MB.

slide-4
00:02:00.070 --> 00:02:01.860
Here are some performance numbers that I've gathered,

52
00:02:01.860 --> 00:02:04.300
writing a small C++ program on my extremely high-end

53
00:02:04.300 --> 00:02:06.150
Linux workstation,

54
00:02:06.150 --> 00:02:08.100
of copying a single frame of this size.

55
00:02:09.530 --> 00:02:11.580
A video frame in YUV420, full HD,

56
00:02:11.580 --> 00:02:14.480
standard dynamic range, takes about 1.5ms to

57
00:02:14.480 --> 00:02:16.390
copy when the cache is hot,

58
00:02:16.390 --> 00:02:18.560
which means the source is already in the cache.

59
00:02:18.560 --> 00:02:22.210
And 4.5ms if not. The source needs to be fetched from memory.

60
00:02:22.210 --> 00:02:24.560
Two frames easily fit in the cache of this CPU.

61-p
00:02:26.210 --> 00:02:27.043
A video frame

62
00:02:27.043 --> 00:02:30.290
in YUV 420, 4K, standard dynamic range,

63
00:02:30.290 --> 00:02:35.290
takes 6.6ms and 17ms when in CPU cache.

64
00:02:36.380 --> 00:02:38.040
This only works because the CPU I'm running on

65
00:02:38.040 --> 00:02:41.733
has lots of cache, and a single frame still fits.

66-p
00:02:42.590 --> 00:02:46.555
A video frame in P010, full HD, high dynamic range

67
00:02:46.555 --> 00:02:48.930
either 10 or 12 bits, takes 15ms

68
00:02:48.930 --> 00:02:51.820
if the caches are hot and 33ms if not.

69
00:02:51.820 --> 00:02:55.410
The CPU I'm running this on has 20MB of L3 cache.

70
00:02:55.410 --> 00:02:57.230
So only a partial frame fits.

71-p
00:02:58.250 --> 00:02:59.130
Considering the budget

72
00:02:59.130 --> 00:03:03.921
for a single frame at 30Hz is 33ms and

73
00:03:03.921 --> 00:03:05.460
16.6ms at 60Hz,

74
00:03:05.460 --> 00:03:08.690
we can quickly see that the numbers here are uncomfortable,

75
00:03:08.690 --> 00:03:12.510
and minimizing memory copies are going to be of importance.

76
00:03:12.510 --> 00:03:14.740
I'll repeat that standard scenarios in WebCodecs such as

77
00:03:14.740 --> 00:03:16.500
playback don't make copies.

78
00:03:16.500 --> 00:03:18.130
I'm talking about advanced use cases here,

79
00:03:18.130 --> 00:03:19.243
such as processing.

slide-5
00:03:20.650 --> 00:03:21.720
Additionally,

81
00:03:21.720 --> 00:03:24.340
GPU to CPU copies (read back)

82
00:03:24.340 --> 00:03:27.370
and CPU to GPU copies (texture uploads)

83
00:03:27.370 --> 00:03:29.200
are also quite expensive.

84
00:03:29.200 --> 00:03:31.710
It's best to carefully consider when and how they need to be

85
00:03:31.710 --> 00:03:32.543
done,

86
00:03:32.543 --> 00:03:34.130
and to try to minimize transfers,

87
00:03:34.130 --> 00:03:37.510
if possible. WebCodecs has been carefully designed to allow

88
00:03:37.510 --> 00:03:41.240
to easily leave VideoFrames on the GPU and makes all copies

89
00:03:41.240 --> 00:03:42.093
explicit.

slide-6
00:03:43.490 --> 00:03:46.750
But sometimes it's really necessary to perform copies/

91
00:03:46.750 --> 00:03:48.640
Here are three scenario

92
00:03:48.640 --> 00:03:49.940
when this is unavoidable.

93-p
00:03:50.810 --> 00:03:52.480
Custom processing of video frames that

94
00:03:52.480 --> 00:03:55.180
are on the GPU using regular JavaScript or WASM code

95
00:03:55.180 --> 00:03:57.690
in which case we need to read back.

96-p
00:03:57.690 --> 00:04:00.387
Custom processing of video frames that are on the CPU,

97
00:04:00.387 --> 00:04:01.560
via WASM,

98
00:04:01.560 --> 00:04:04.590
then the data needs to be copied into the WASM heap,

99
00:04:04.590 --> 00:04:07.470
or working with other web API that requires copies.

100-p
00:04:07.470 --> 00:04:08.303
For example,

101
00:04:08.303 --> 00:04:10.980
playing audio data with an AudioWorklet will require

102
00:04:10.980 --> 00:04:13.180
copying into the AudioWorklet output buffer.

slide-7
00:04:14.820 --> 00:04:15.860
As said,

104
00:04:15.860 --> 00:04:17.030
WebCodecs has been designed with

105
00:04:17.030 --> 00:04:18.470
copy minimization in mind.

106
00:04:18.470 --> 00:04:21.060
The memory is not visible directly to script,

107
00:04:21.060 --> 00:04:23.350
and authors need to call a function called "copyTo"

108
00:04:23.350 --> 00:04:26.650
to get an ArrayBuffer that can be directly manipulated.

109
00:04:26.650 --> 00:04:29.310
This "copyTo" method can also take care of conversion in

110
00:04:29.310 --> 00:04:31.000
certain cases.

111
00:04:31.000 --> 00:04:33.990
when calling clone on a VideoFrame or AudioData object,

112
00:04:33.990 --> 00:04:37.760
the underlying resources are referenced for a second

113
00:04:37.760 --> 00:04:38.593
time,

114
00:04:38.593 --> 00:04:39.720
instead of copied,

115
00:04:39.720 --> 00:04:41.950
so a single frame can be used in different context

116
00:04:41.950 --> 00:04:43.400
efficiently.

117
00:04:43.400 --> 00:04:45.303
Doing a deep copy is still possible.

118-p
00:04:47.070 --> 00:04:47.903
Now,

119
00:04:47.903 --> 00:04:50.640
let's see a number of copies that exist today in WebCodecs

120-p
00:04:50.640 --> 00:04:51.473
First,

121
00:04:51.473 --> 00:04:54.603
the compressed input of a decoder is currently copied.

122
00:04:55.490 --> 00:04:57.037
This is not that problematic because the input is a lot

123
00:04:57.037 --> 00:04:58.880
smaller than the output.

124
00:04:58.880 --> 00:05:00.477
It could be optimized.

125-p
00:05:00.477 --> 00:05:01.760
More importantly,

126
00:05:01.760 --> 00:05:04.010
there is currently no way to become the owner of the memory

127
00:05:04.010 --> 00:05:06.060
behind a VideoFrame or an AudioData,

128
00:05:06.060 --> 00:05:07.230
when it's regular memory,

129
00:05:07.230 --> 00:05:08.183
non GPU.

130-p
00:05:09.560 --> 00:05:10.810
Finally,

131
00:05:10.810 --> 00:05:11.970
the API

132
00:05:11.970 --> 00:05:14.720
for now does a lot of allocations and deallocation,

133
00:05:14.720 --> 00:05:16.623
trashing CPU caches unnecessarily.

slide-8
00:05:17.710 --> 00:05:20.170
Here are two simple design proposal to fix the two last

135
00:05:20.170 --> 00:05:21.700
points in this list.

slide-9
00:05:21.700 --> 00:05:22.960
First,

137
00:05:22.960 --> 00:05:25.520
a method called "detach" could return an ArrayBuffer and

138
00:05:25.520 --> 00:05:27.550
close the video frame in one call,

139
00:05:27.550 --> 00:05:29.810
skipping a copy when possible,

140
00:05:29.810 --> 00:05:31.530
for example, when it hasn't been cloned,

141
00:05:31.530 --> 00:05:33.740
that's fairly common.

142
00:05:33.740 --> 00:05:36.040
Similarly, we can add this method on AudioData.

slide-10
00:05:37.570 --> 00:05:38.530
Next,

144
00:05:38.530 --> 00:05:41.580
we can limit the native allocation and deallocation pressure by

145
00:05:41.580 --> 00:05:44.300
taking a buffer in the decode method, in which the decoded

146
00:05:44.300 --> 00:05:46.150
data is going to be written to,

147
00:05:46.150 --> 00:05:49.000
and getting back the input buffer to reuse,

148
00:05:49.000 --> 00:05:50.560
in the output callback.

149
00:05:50.560 --> 00:05:53.410
This will matter a lot for audio where it's a lot easier for

150
00:05:53.410 --> 00:05:54.800
buffer to fit in CPU caches,

151
00:05:54.800 --> 00:05:58.693
but their numbers are a lot bigger.

slide-11
00:06:00.990 --> 00:06:02.200
Now let's talk,

153
00:06:02.200 --> 00:06:04.880
about some of the harder problems faced on the

154
00:06:04.880 --> 00:06:06.620
web platform today.

155-p
00:06:06.620 --> 00:06:07.620
First,

156
00:06:07.620 --> 00:06:10.190
the necessity to copy from into the WASM heap becomes

157
00:06:10.190 --> 00:06:12.300
problematic when the data to copy is big enough,

158
00:06:12.300 --> 00:06:15.790
such as video frames. Decoding into the WASM heap would be

159
00:06:15.790 --> 00:06:18.323
a welcomed feature, but this needs some work.

160-p
00:06:19.160 --> 00:06:22.410
Then there is a problem of passing views over SharedArrayBuffer

161
00:06:22.410 --> 00:06:23.940
to APIs.

162
00:06:23.940 --> 00:06:27.160
SharedArrayBuffer is often a good solution to limit copies,

163
00:06:27.160 --> 00:06:30.640
but it's often unclear what those API do to memory

164
00:06:30.640 --> 00:06:34.180
and if they work with concurrent writes to the memory region

165
00:06:34.180 --> 00:06:35.630
that has been passed to them.

166
00:06:36.770 --> 00:06:39.010
Having read-only memory ranges on SharedArrayBuffer,

167
00:06:39.010 --> 00:06:40.470
could be a solution here,

168
00:06:40.470 --> 00:06:41.820
but it's a complex problem.

169-p
00:06:43.100 --> 00:06:45.650
An effort has been started to try to document the problems

170
00:06:45.650 --> 00:06:47.897
about copies on the platform at the WICG,

171
00:06:47.897 --> 00:06:50.770
and I encourage interested parties to voice their

172
00:06:50.770 --> 00:06:54.500
opinions and contribute their experience to the discussion,

173
00:06:54.500 --> 00:06:57.970
reports from the field are always welcomed and very

174
00:06:57.970 --> 00:07:00.720
important to inform future developments.

slide-12
00:07:00.720 --> 00:07:01.940
In conclusion,

176
00:07:01.940 --> 00:07:04.590
while WebCodecs can and will be improved when it comes

177
00:07:04.590 --> 00:07:05.800
to memory access.

178
00:07:05.800 --> 00:07:08.530
it's already extremely powerful and common use cases

179
00:07:08.530 --> 00:07:10.150
are already quite fast,

180
00:07:10.150 --> 00:07:11.100
Making it perfect

181
00:07:11.100 --> 00:07:13.500
is definitely possible and will probably happen in the

182
00:07:13.500 --> 00:07:14.840
future.

183
00:07:14.840 --> 00:07:15.673
Thanks.
