WEBVTT

1
00:05.400 --> 00:09.000
Hi, 我是俊跃

2
00:09.000 --> 00:11.160
我是多媒体团队的软件工程师

3
00:11.160 --> 00:13.280
来自字节跳动

4
00:13.280 --> 00:16.240
今天我想分享一下我们的

5
00:16.240 --> 00:19.920
基于 Web 的非线性视频编辑器

6
00:19.920 --> 00:23.120
它是用 C++ 编写，并且用 WebAssembly 和 EMScripten 进行搭建

slide-2
00:23.120 --> 00:25.000
Slide 2

9
00:25.000 --> 00:27.840
这是我的演讲的几个主题

10
00:27.840 --> 00:30.920
首先我会介绍一下这个视频编辑器是做什么的

11
00:30.920 --> 00:34.200
然后我会简单介绍其工作原理

12
00:34.200 --> 00:36.880
最后我会讲讲

13
00:36.880 --> 00:39.120
开发过程中的一些开发者需求

slide-3
00:39.160 --> 00:41.440
Slide 3

16
00:41.440 --> 00:44.200
视频剪辑对每一位视频内容创作者而言

17
00:44.200 --> 00:46.800
都是非常重要的

18
00:46.800 --> 00:49.640
它是视频创作的最终步骤之一

19
00:49.640 --> 00:53.520
它能把你的视频片段变成一个完整的故事

20
00:53.520 --> 00:56.680
现有有很多的视频剪辑软件

21
00:56.680 --> 01:00.880
包括桌面应用和移动应用

22
01:00.880 --> 01:03.720
或者基于云的软件

24-p
01:03.720 --> 01:08.520
我们所做的则是一款基于 Web 构建的多轨视频剪辑器

25
01:08.520 --> 01:12.400
用户可以通过 Web 浏览器添加视频剪辑

26
01:12.400 --> 01:17.240
音频片段，字幕，过渡，特效等等

27
01:17.240 --> 01:20.880
利用 Web 技术

28
01:20.880 --> 01:24.960
和云存储，用户可以

29
01:24.960 --> 01:30.000
在任何时间任何电脑上打开项目继续工作

slide-4
01:30.000 --> 01:32.200
Slide 4

32
01:32.200 --> 01:34.680
一开始我们的核心引擎

33
01:34.680 --> 01:38.120
是使用 C++ 写在 native 原生平台的

34
01:38.120 --> 01:40.720
它是个多线程的引擎

35
01:40.720 --> 01:45.840
可以在 Android, iOS, Windows 以及 MacOS 上运行

36
01:45.840 --> 01:48.800
随着浏览器

37
01:48.800 --> 01:51.720
对 WebAssembly 的支持和优化，我们现在有机会

38
01:51.720 --> 01:54.440
把这个引擎迁移到 Web

40-p
01:56.400 --> 01:59.320
我们使用了 WebGL 和其它的一些相关技术

41
01:59.320 --> 02:01.280
进行实时视频渲染

42
02:01.280 --> 02:06.120
其实，WebAssembly 已经不再是个新技术

43
02:06.120 --> 02:08.800
所以这里不再详细阐述

44
02:08.800 --> 02:11.160
WebAssembly 和 EMScripten 的每一个技术细节

slide-5
02:11.160 --> 02:12.640
Slide 5

47
02:12.640 --> 02:16.760
这个图表展示了这款应用的一个简单架构

48
02:16.760 --> 02:21.000
我们为网页提供 JS APIs 从而操控这个引擎

49
02:21.000 --> 02:26.200
这些 JS APIs 唤起 C++ 引擎使用 EMScripten 进行编译

50
02:26.200 --> 02:30.440
同时 C++ 引擎唤起 EMScripten 提供的浏览器特色 API

51
02:30.440 --> 02:34.960
去执行相关功能

52
02:34.960 --> 02:39.240
例如视频和特效渲染的 WebGL 相关操作

53
02:39.240 --> 02:46.560
用 WebAudio 实现音频播放，Web Workers 实现多线程运行时

54
02:46.560 --> 02:52.640
以及用 IndexedDB 进行文件系统持久式存储

slide-6
02:52.640 --> 02:54.480
Slide 6

57
02:54.480 --> 02:57.600
这个图表展示了在一个简单的视频处理流程中

58
02:57.600 --> 03:00.640
有哪些浏览器功能被用到处理途径中

60-p
03:00.640 --> 03:04.400
首先，视频部分

61
03:04.400 --> 03:07.920
对每个视频轨迹，我们首先都使用到了 WebAssembly

62
03:07.920 --> 03:10.400
进行视频帧的解码

63
03:10.400 --> 03:15.560
获得已解码的视频后，我们把它转换成纹理 texture

64
03:15.560 --> 03:19.440
然后把多个视频轨迹的纹理进行混合

65
03:19.440 --> 03:22.400
并且通过 WebGL 把它们显示到 canvas

67-p
03:22.400 --> 03:27.520
在音频部分，我们也使用了 WebAssembly 进行解码

68
03:27.520 --> 03:32.920
然后把解码后的数据发送到 Web Audio API 进行播放

70-p
03:33.840 --> 03:36.520
当然，对所有的视频播放器

71
03:36.520 --> 03:39.680
音视频同步是必不可少的

72
03:39.680 --> 03:44.200
这里展示的是一个简化后的处理途径

73
03:44.200 --> 03:46.400
我省略了很多步骤

74
03:46.400 --> 03:49.160
实际的解决方案

75
03:49.160 --> 03:50.520
会比这里展示的复杂得多

slide-7
03:50.520 --> 03:52.400
Slide 7

78
03:52.400 --> 03:56.960
到此，我们基本可以让这个应用跑起来

79
03:56.960 --> 04:00.800
但这并不意味着它已经是完美的

80
04:00.800 --> 04:03.160
在某些地方还是很不尽人意

82-p
04:04.160 --> 04:07.440
第一个问题是解码操作的性能

83
04:07.440 --> 04:10.240
我们需要同时对多个视频轨道进行解码

84
04:10.240 --> 04:12.920
对性能而言

85
04:12.920 --> 04:14.560
是音频解码方面很大的挑战

86
04:14.560 --> 04:18.440
使用 WebAssembly 进行解码会耗费大量的 CPU 资源

87
04:18.440 --> 04:20.720
而且它的速度比不上 native

88
04:20.720 --> 04:25.320
到现在为止，为了支持尽可能多的视频轨道

89
04:25.320 --> 04:30.640
我们把视频的分辨率限制在 480p

91-p
04:30.640 --> 04:33.960
通过引入 WebCodecs

92
04:33.960 --> 04:36.800
我们也许有机会改善我们的视频分辨率

93
04:36.800 --> 04:42.480
在一个线程中使用 WebCodecs, 即一个 worker

94
04:42.480 --> 04:45.560
使用同步的 WebCodecs API

95
04:45.560 --> 04:47.800
对 C++ 代码来说集成起来更加友好

slide-8
04:47.800 --> 04:51.240
Slide 8

98
04:51.240 --> 04:55.000
另一个需求是更好的调试体验

100-p
04:55.000 --> 04:59.560
在允许 DWARF 的 debug 模式时

101
04:59.560 --> 05:02.120
WASM 文件体积会变得特别庞大

102
05:02.120 --> 05:04.240
对我们而言，它超过了 1 GB

103
05:04.240 --> 05:08.840
这会让浏览器变成非常不稳定

104
05:08.840 --> 05:13.320
运行一段时间后浏览器会非常容易崩溃

105
05:13.320 --> 05:14.120
而且速度缓慢

106
05:14.120 --> 05:18.000
哪怕是在 localhost 进行调试

107
05:18.000 --> 05:20.440
加载 DWARF 也需要花费超过10秒的时间

108
05:20.440 --> 05:25.160
而且这个开发者工具反应缓慢并且很容易卡住

110-p
05:25.160 --> 05:29.880
其次，在一个多线程应用中

111
05:29.880 --> 05:33.120
一个有含义的线程命名，也就是 worker 的名字

112
05:33.120 --> 05:35.280
对调试来说是非常有帮助的

113
05:35.280 --> 05:38.120
现在的 Web Worker 只支持

114
05:38.120 --> 05:40.720
在它被创建时候指定的名字

115
05:40.720 --> 05:44.920
我们希望能在 Web Worker 使用过程中运行对它进行重命名

116
05:44.920 --> 05:47.480
这会对定位所需要找到的线程非常有帮助

118-p
05:47.480 --> 05:50.240
第三，我们需要允许一个中止全部的操作

119
05:50.240 --> 05:54.240
当前，开发者工具只能选择一个线程

120
05:54.240 --> 05:56.160
并点击暂停按钮

121
05:56.160 --> 05:58.400
它会暂停这个 worker 或者主线程

122
05:58.400 --> 06:00.600
但当同时存在很多的线程的时候

123
06:00.600 --> 06:03.640
就需要一个接一个地点击暂停按钮

124
06:03.640 --> 06:07.120
类似的，现在的重启按钮

125
06:07.120 --> 06:09.160
也需要一个接一个地点击

126
06:09.160 --> 06:13.560
在这方面，我认为我们可以参照

127
06:13.560 --> 06:16.360
大部分流行的 IDE 的调试习惯

slide-9
06:16.400 --> 06:19.360
Slide 9

130
06:19.360 --> 06:23.240
如这张图显示的，EMScripten 提供了一个文件系统

131
06:23.240 --> 06:28.400
支持直接使用原生的 POSIX 文件 API

132
06:28.400 --> 06:32.880
对浏览器而言，它主要引入了 MEMFS 和 IDBFS.

134-p
06:32.880 --> 06:36.480
然而，视频文件通常体积庞大

135
06:36.480 --> 06:40.520
当我们使用 MEMFS 去读大文件时

136
06:40.520 --> 06:44.400
内存的消耗会非常大

137
06:44.400 --> 06:48.280
因为它把整个文件读进了内存

138
06:48.280 --> 06:49.320
这会非常容易导致 out-of-memory error

139
06:49.320 --> 06:52.800
同时，多线程访问

140
06:52.800 --> 06:55.600
总是会在主线程创建代理

141
06:55.600 --> 06:59.440
导致对主线程一定程度的性能影响

143-p
06:59.440 --> 07:02.880
因此，我认为我们需要一个更好的文件系统

144
07:02.880 --> 07:05.560
支持更完备的多线程访问

145
07:05.560 --> 07:10.360
和更少的内存消耗以及更好的持久化方案

147-p
07:10.360 --> 07:12.440
OK。这是我今天希望跟大家分享的内容

148
07:12.440 --> 07:15.800
非常感谢
