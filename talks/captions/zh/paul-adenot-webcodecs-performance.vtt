WEBVTT

1
00:07.750 --> 00:08.583
<v ->大家好</v>

2
00:08.583 --> 00:09.900
我是 Paul Adenot

3
00:09.900 --> 00:12.360
我在 Mozilla

4
00:12.360 --> 00:13.780
从事 Firefox 上任何跟音频视频相关的工作

5-p
00:13.780 --> 00:14.720
今天

6
00:14.720 --> 00:18.300
我希望分享一个最近的 API，名为 WebCodecs API

7
00:18.300 --> 00:20.240
尤其是跟内存访问模式相关的部分

8
00:20.240 --> 00:23.170
在这个 API与其它 API 共同使用

9
00:23.170 --> 00:24.620
在 Web 平台上执行操作的时候

10
00:24.620 --> 00:26.730
我们将讨论一些原始的性能数据

11
00:26.730 --> 00:28.590
当访问视频帧的时候

12
00:28.590 --> 00:30.600
今天什么样的 WebCodecs 可以最小化内存消耗

13
00:30.600 --> 00:31.810
访问开销

14
00:31.810 --> 00:34.440
和这个 API 今天还存在的一些问题

15
00:34.440 --> 00:37.410
有相关的解决方案，还还没有得到实现

16
00:37.410 --> 00:40.910
更重要的是关于几个更困难的问题

17
00:40.910 --> 00:42.180
我们将来要解决

18
00:42.180 --> 00:44.650
以便让 WebCodecs 的使用

19
00:44.650 --> 00:46.113
拥有和 native app 一样的性能特质

20-p
00:47.850 --> 00:49.150
在开始之前

21
00:49.150 --> 00:50.930
我想说的是，任何简单的场景

22
00:50.930 --> 00:53.500
例如解码、视频渲染和音频渲染

23
00:53.500 --> 00:55.150
在今天已经得到相当充分的优化

24
00:55.150 --> 00:57.210
我们将讨论一些高级用例

25
00:57.210 --> 00:58.400
比如大型原生应用

26
00:58.400 --> 01:01.833
编译为使用 WebCodecs 的 WebAssembly

27
01:01.833 --> 01:05.190
从而加速他们的编码和解码操作

28
01:05.190 --> 01:06.220
或其它的一些程序

29
01:06.220 --> 01:08.810
在大量使用 WebCodecs 的时候

30
01:08.810 --> 01:11.193
并希望最大限度地减少任何低效率操作

slide-2
01:12.770 --> 01:13.603
但首先

32
01:13.603 --> 01:14.890
让我重复一句老话

33
01:14.890 --> 01:17.310
在自由软件多媒体开发界中

34
01:17.310 --> 01:18.430
经常提到的

35
01:18.430 --> 01:22.600
"memcpy 是谋杀". 在这句诙谐的句子背后

36
01:22.600 --> 01:25.360
是一个重要的事实: 为了最大限度地提高性能

37
01:25.360 --> 01:28.170
需要最大程度减少内存副本

38
01:28.170 --> 01:31.240
并且这个 App 的工作集需要尽可能地小

39
01:31.240 --> 01:33.933
从而理想化地匹配 CPU 缓存

40
01:35.270 --> 01:37.300
将内存提取到缓存中是很慢的

41
01:37.300 --> 01:38.390
缓存体积很小

42
01:38.390 --> 01:40.400
所以不应该发生重复

slide-3
01:41.220 --> 01:44.540
但首先让我们考虑一下这个体积大小问题

44-p
01:44.540 --> 01:49.150
YUV420 格式的视频帧，全高清，标准动态范围

45
01:49.150 --> 01:50.613
大约是 4MB

46
01:51.450 --> 01:54.170
YUV420 格式的视频帧，4K,

47
01:54.170 --> 01:55.630
标准动态范围

48
01:55.630 --> 01:57.530
大约是 16MB

49
01:57.930 --> 02:01.600
P010 格式的视频帧，全高清，高动态范围

50
02:01.600 --> 02:05.253
（10 位或 12 位）大约为 32MB

slide-4
02:06.570 --> 02:08.360
以下是我收集的一些性能数据

52
02:08.360 --> 02:10.800
编写一个小的 C++ 程序

53
02:10.800 --> 02:12.650
在我的极高端的 Linux 工作站上

54
02:12.650 --> 02:14.600
去复制这种大小的一个帧

55
02:16.300 --> 02:18.800
YUV420 格式的视频帧，全高清

56
02:18.800 --> 02:20.980
标准动态范围, 大概需要 1.5ms

57
02:20.980 --> 02:22.890
在热缓存状态时完成复制操作

58
02:22.890 --> 02:25.600
即资源已经在缓存中的情况

59
02:25.600 --> 02:28.710
如果不在，则需要 4.5ms。 资源需要从内存中获取

60
02:28.710 --> 02:31.600
两个帧则很容易放进这个 CPU 的缓存中

61-p
02:32.710 --> 02:36.790
YUV 420 格式的视频帧，4K，标准动态范围

63
02:36.790 --> 02:41.790
在 CPU 缓存的情况则需要6.6ms 和17ms

64
02:42.880 --> 02:44.540
能出现这个效果是因为我跑的 CPU

65
02:44.540 --> 02:48.233
有非常多的缓存，并且还符合单个视频帧

66-p
02:49.900 --> 02:53.550
P010 格式的一个视频帧，全高清，高动态范围

67
02:53.550 --> 02:55.430
10位或者12位的，需要15ms 如果是热缓存

68
02:55.430 --> 02:58.320
如果不是则需要33ms

69
02:58.320 --> 03:01.910
这个用例里我跑的 CPU 有20MB的L3缓存

70
03:01.910 --> 03:03.730
所以只有部分的视频帧适配

71-p
03:04.750 --> 03:05.630
考虑到预算

72
03:05.630 --> 03:10.421
对于 30Hz 的单帧是 33ms

73
03:10.421 --> 03:11.960
而60Hz 的单帧则是16.6ms

74
03:11.960 --> 03:15.190
我们很快就可以看出这里的数字并不宜人

75
03:15.190 --> 03:19.100
将内存副本数量降到最低是很重要的

76
03:19.100 --> 03:21.240
我将重复 WebCodecs 中的标准场景，例如

77
03:21.240 --> 03:23.000
播放而不生成副本

78
03:23.000 --> 03:24.630
我在这里要谈论一些高级用例

79
03:24.630 --> 03:25.743
比如视频处理

slide-5
03:27.150 --> 03:28.220
另外，

81
03:28.220 --> 03:30.840
GPU 到 CPU 副本 (回读)

82
03:30.840 --> 03:33.870
和 CPU 到 GPU 副本 (纹理上传)

83
03:33.870 --> 03:35.700
也是非常昂贵的

84
03:35.700 --> 03:39.430
最好慎重考虑何时以及如何完成它们

86
03:39.430 --> 03:40.630
并且可能的话尽量减少传输

87
03:40.630 --> 03:44.100
WebCodecs 经过精心设计，允许

88
03:44.100 --> 03:47.740
轻松地将 VideoFrames 留在 GPU 上并制作所有副本

89
03:47.740 --> 03:48.593
并将所有副本制作变成显式的

slide-6
03:49.990 --> 03:53.250
但有时确实需要执行副本

91
03:53.250 --> 03:55.140
下面是

92
03:55.140 --> 03:56.440
三个当这是不可避免的场景

93-p
03:57.310 --> 03:58.980
自定义处理

94
03:58.980 --> 04:01.680
在 GPU 上使用常规 JavaScript 或 WASM 代码的视频帧

95
04:01.680 --> 04:04.190
在这种情况下，我们需要回读

96-p
04:04.190 --> 04:08.600
通过 WASM 自定义处理 CPU 上的视频帧

98
04:08.600 --> 04:11.900
然后需要将数据复制到 WASM 堆中

99
04:11.900 --> 04:13.970
或使用其它需要副本的 Web API

100-p
04:13.970 --> 04:14.803
例如

101
04:14.803 --> 04:17.480
使用 AudioWorklet 处理音频数据需要

102
04:17.480 --> 04:19.680
复制到 AudioWorklet 输出缓冲区

slide-7
04:21.320 --> 04:22.360
正如之前说过

104
04:22.360 --> 04:23.530
WebCodecs 被设计为

105
04:23.530 --> 04:24.970
时刻考虑最少化复制操作

106
04:24.970 --> 04:27.560
内存对于脚本是不可见的

107
04:27.560 --> 04:29.850
并且作者需要调用一个名为 “copyTo” 的函数

108
04:29.850 --> 04:33.150
来获得一个可以直接操作的 ArrayBuffe

109
04:33.150 --> 04:35.810
这个“copyTo”方法

110
04:35.810 --> 04:37.500
也可以处理特定的一些用例

111
04:37.500 --> 04:40.490
当在 VideoFrame 或 AudioData 对象上调用 clone 时

112
04:40.490 --> 04:45.930
底层资源将被第二次引用

114
04:45.930 --> 04:46.220
而不是复制

115
04:46.220 --> 04:49.900
从而可以在不同的上下文中有效地使用单个帧

117
04:49.900 --> 04:51.803
并且仍然可以进行深度克隆

118-p
04:53.570 --> 04:57.140
现在，让我们看看今天在 WebCodecs 中存在的一些副本

120-p
04:57.140 --> 05:01.103
首先，解码器的压缩输入 compressed input 当前正被复制

122
05:01.990 --> 05:03.537
这不会引起问题，因为输入

123
05:03.537 --> 05:05.380
比输出小得多

124
05:05.380 --> 05:06.977
它可以被优化

125-p
05:06.977 --> 05:08.260
更重要的是

126
05:08.260 --> 05:10.510
目前没有办法成为

127
05:10.510 --> 05:12.560
VideoFrame 或 AudioData 背后的内存的拥有者

128
05:12.560 --> 05:14.683
当它是常规的内存，而非 GPU 的时候

130-p
05:16.600 --> 05:17.310
最后

131
05:17.310 --> 05:21.220
当前的 API 做了大量的分配和释放

133
05:21.220 --> 05:23.123
不必要地抖动 CPU 缓存

slide-8
05:24.210 --> 05:26.670
这里有两个简单的设计方案来解决

135
05:26.670 --> 05:28.200
这个清单里的最后两个问题

slide-9
05:28.200 --> 05:29.460
首先

137
05:29.460 --> 05:32.200
一个名为“detach”的方法可以返回一个 ArrayBuffer 和

138
05:32.200 --> 05:34.500
在一个调用里关闭视频帧

139
05:34.500 --> 05:36.310
尽可能跳过副本

140
05:36.310 --> 05:38.300
例如，当它还没有被关闭时

141
05:38.300 --> 05:40.240
这是相当普遍的情况

142
05:40.240 --> 05:42.540
类似的，我们可以在 AudioData 添加这个方法

slide-10
05:44.700 --> 05:45.300
接下来

144
05:45.300 --> 05:48.800
我们可以通过以下方式来限制 native allocation 和 deallocation 带来的压力

145
05:48.800 --> 05:50.800
在 decode 方法中取一个缓冲区，其中 decode 的

146
05:50.800 --> 05:52.650
数据将被写入

147
05:52.650 --> 05:55.500
并取回输入缓冲区以

148
05:55.500 --> 05:57.600
在输出回调中重新使用

149
05:57.600 --> 05:59.910
这对于音频来说很重要，因为

150
05:59.910 --> 06:01.300
其缓冲区更容易适应 CPU 缓存

151
06:01.300 --> 06:05.193
但它们的数量要多得多

slide-11
06:07.490 --> 06:11.380
现在让我们来谈谈

154
06:11.380 --> 06:13.120
今天 Web 平台的一些更棘手的问题

155-p
06:13.120 --> 06:14.120
首先

156
06:14.120 --> 06:16.690
从 WASM 堆复制和复制到 WASM 堆的必要性变得

157
06:16.690 --> 06:18.800
当要复制的数据变得足够大时会出现问题

158
06:18.800 --> 06:22.290
例如对视频帧。 解码到 WASM 堆将是

159
06:22.290 --> 06:24.823
一个受欢迎的功能，但这需要一些努力

160-p
06:25.660 --> 06:30.440
然后还有一个通过 SharedArrayBuffer 将视图传递给 API 的问题

162
06:30.440 --> 06:33.660
SharedArrayBuffer 通常是个限制副本的好方法

163
06:33.660 --> 06:37.140
但通常很难弄清楚这些 API 对内存做了什么

164
06:37.140 --> 06:40.680
以及它们是否

165
06:40.680 --> 06:42.130
与对传递给它们的内存区域的并发写入一起使用

166
06:43.270 --> 06:45.510
在 SharedArrayBuffer 设定 read-only 范围

167
06:45.510 --> 06:46.970
在这里可能是一个解决方案

168
06:46.970 --> 06:48.320
但这毕竟是一个复杂的问题

169-p
06:49.600 --> 06:52.150
在 WICG 已经有一个项目启动开始整理相关问题

170
06:52.150 --> 06:54.397
关于 Web 平台上的内存副本

171
06:54.397 --> 06:57.270
我鼓励感兴趣的各方表达他们的意见

172
06:57.270 --> 07:01.000
并在讨论中分享相关的实践经验

173
07:01.000 --> 07:04.470
非常欢迎来自这个领域的汇报

174
07:04.470 --> 07:07.220
这些对于未来的开发是有重要意义的

slide-12
07:07.220 --> 07:08.440
总而言之

176
07:08.440 --> 07:12.300
虽然 WebCodecs 在内存访问方面还可以并且将会得到改进

178
07:12.300 --> 07:15.300
它已经是非常有效的

179
07:15.300 --> 07:16.650
而且性能很好

180
07:16.650 --> 07:21.340
让它趋于完美当然是可能的，而且未来将会发生

183
07:21.340 --> 07:22.173
谢谢
