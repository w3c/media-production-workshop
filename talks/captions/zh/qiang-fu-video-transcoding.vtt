WEBVTT

1
00:07.100 --> 00:08.300
<v ->大家好</v>

2
00:08.300 --> 00:10.620
我是来自 Bilibili 的付强

3
00:10.620 --> 00:12.360
我的演讲主题是

4
00:12.360 --> 00:13.930
浏览器上的视频转码方案

5-p
00:13.930 --> 00:17.670
我将会介绍几种可以实现这个功能的几种可行方案

6
00:17.670 --> 00:21.420
并且为 Web 开发者提供一些 Web API 方面的建议

7
00:21.420 --> 00:23.900
让视频转码更加简便易行

8-p
00:23.900 --> 00:27.890
Bilibili 是中国的一个面向用户的视频内容应用网站

9
00:27.890 --> 00:31.138
有点类似 YouTube

10-p
00:31.138 --> 00:32.750
好的，下面进入正题

slide-2
00:35.400 --> 00:38.930
为什么我们要关注这个话题？为了用浏览器实现一些新功能

12
00:38.930 --> 00:40.850
我们需要研究这个方向

13-p
00:40.850 --> 00:43.520
第一个需求是关于视频的预览

14
00:43.520 --> 00:45.250
有一些视频格式

15
00:45.250 --> 00:48.870
像 AVI 或 FLV

16
00:48.870 --> 00:49.703
不能直接被 HTML 播放

17
00:49.703 --> 00:53.940
当然。我们可以用 WebAssembly 或 JavaScript

18
00:53.940 --> 00:55.320
针对这些视频实现一个播放器

19
00:55.320 --> 00:59.325
但如果我们能把它们转码成 MP4 或 WebM 格式

20
00:59.325 --> 01:04.325
那我们就能用一个 video 标签元素直接在 HTML 里播放，非常简便

21-p
01:04.370 --> 01:08.580
另一个需求是源于视频制作相关细节

22
01:08.580 --> 01:10.440
对于某些视频

23
01:10.440 --> 01:12.880
只需要进行微小调整

24
01:12.880 --> 01:15.860
我们只需要提供很小的协助功能

25
01:15.860 --> 01:19.200
去修改视频的分辨率、帧率等等其它参数

26
01:19.200 --> 01:23.490
来实现上传匹配

27
01:23.490 --> 01:26.783
我们的目标是通过视频转码提供一个新的技术方案

slide-3
01:29.510 --> 01:33.380
转码的基本步骤可以被概括为以下几点：

29
01:33.380 --> 01:36.700
把源文件分离成 demuxer 直至获得视频流 streams

30
01:36.700 --> 01:40.260
并且编码成视频块 chunks

31
01:40.260 --> 01:42.270
然后把这些视频块传给一个解码器 decoder 获得视频帧 frame

32
01:42.270 --> 01:45.660
后面我们可能还需要对帧进行一些操作

33
01:45.660 --> 01:47.510
在逆链路把文件传输以后

34
01:47.510 --> 01:49.600
我们最终获得输出文件

35-p
01:49.600 --> 01:52.600
我把这个过程总结为 FFmpeg

36
01:52.600 --> 01:53.833
但我们如何在浏览器中使用它？

slide-4
01:56.678 --> 01:59.450
Web 开发者有一个很流行的方式

38
01:59.450 --> 02:01.280
可以进行视频转码

39
02:01.280 --> 02:04.311
WebAssembly 可以派上用场。在把 FFmpeg 源码编译成

40
02:04.311 --> 02:07.700
WebAssembly 以后，在浏览器运行

41
02:07.700 --> 02:09.510
并且给予指令

42
02:09.510 --> 02:12.970
我们就可以对视频进行所需要的操作。第一眼看是很简单的

43-p
02:12.970 --> 02:16.800
但 WebAssembly 看起来像个黑盒

44
02:16.800 --> 02:19.433
而且开发者并不在乎里面的细节。我们一起看看它的工作原理

slide-5
02:21.590 --> 02:23.680
虽然 WebAssembly 是个黑盒

46
02:23.680 --> 02:26.830
我们还是需要一些准备工作。首先

47
02:26.830 --> 02:30.110
是对 FFmpeg 的熟悉度. 我们还需要学习一下

48
02:30.110 --> 02:34.280
EMScripten 如何工作以及其最佳基础设计概念

49
02:34.280 --> 02:37.620
最后一步是在浏览器中运行 WebAssembly

50-p
02:37.620 --> 02:41.160
当你掌握了这几步和尝试一些 demo 以后，也许几个常见问题就会浮现在眼前

51
02:41.160 --> 02:44.300
为什么它速度那么慢？

52
02:44.300 --> 02:47.570
为什么同样的指令

53
02:47.570 --> 02:50.900
在浏览器和 OS 之间性能差距那么大. 我如何能

54
02:50.900 --> 02:52.100
让它运行速度更快？

55-p
02:52.100 --> 02:55.410
答案还是挺艰难的。WebAssembly 已经完成了一些改进

56
02:55.410 --> 02:57.534
例如支持 SIMD

57
02:57.534 --> 03:01.980
和多线程等。为了享受这些新属性

58
03:01.980 --> 03:04.896
我们需要经常查看 EMScripten 和 FFmpeg 的配置

59
03:04.896 --> 03:08.831
幸运的话 FFmpeg 会从源代码层面实现支持更新

60
03:08.831 --> 03:12.743
对 Web 开发者来说这可能是过于深奥和艰难

slide-6
03:13.950 --> 03:15.970
让我们一起看看其它途径

62
03:15.970 --> 03:19.140
我们可以把转码分解成

63
03:19.140 --> 03:22.310
不同的部分。每一步有不同的解决方案

64-p
03:22.310 --> 03:23.310
例如，

65
03:23.310 --> 03:27.400
分离demuxer 和合成muxer 可以通过 JavaScript 实现

66
03:27.400 --> 03:31.600
编码encoder 和解码decoder 可以简化为使用 WebCodecs API

67
03:31.900 --> 03:35.120
视频帧可以被绘制在 canvas 或 WebGL

68-p
03:35.120 --> 03:38.570
通过一个集成的方式测试整体成果，每个部分都运行良好

69
03:38.570 --> 03:41.683
我们像玩乐高一样把每个步骤分离成独立模块

70-p
03:43.250 --> 03:46.224
我在 GitHub 检索了一些 repositories

71
03:46.224 --> 03:47.570
最终

72
03:47.570 --> 03:49.640
我可以用这种集成方式实现视频转码

73
03:49.640 --> 03:54.210
分离demuxer 和 解码decoders 可以集成为一个视频播放器

74
03:54.210 --> 03:56.130
来减少 WebAssembly 的代码大小

75
03:56.130 --> 03:59.660
我引进了一些 FFmpeg 的库并且衍生出一些文件

76
03:59.660 --> 04:03.620
这个播放器的最终输出格式是

77
04:03.620 --> 04:04.860
RGB 或者 YUV 格式的视频帧

78
04:04.860 --> 04:08.950
我把它传入 WebCodecs API 以获得编码视频块 encoded video chunk

79
04:08.950 --> 04:12.620
然后视频块流动传入一个合成器muxer 来生成可以观看的 WebM 格式视频

80
04:12.620 --> 04:14.580
最终我获得了我想要的本地视频

81
04:14.580 --> 04:16.333
听起来很完美

slide-8
04:18.320 --> 04:20.659
这个集成方案看起来是足够灵活的

83
04:20.659 --> 04:24.480
我甚至可以通过 JavaScript 来修改 canvas 上的视频帧

84
04:24.480 --> 04:28.790
正如 FFmpeg 上的 filters 能做的那样。 WebCodecs 非常 cool

85
04:28.790 --> 04:32.190
并且它可以提供硬件加速选项

86
04:32.190 --> 04:34.670
开发者不需要过份关注这些细节

87-p
04:34.670 --> 04:38.330
唯一需要担心的是合成器muxer。每个 muxer 都不一样

88
04:38.330 --> 04:41.330
所以我需要分别收集

89
04:41.330 --> 04:44.486
支持 MP4, WebM 和其它格式的合成器解决方案

90
04:44.486 --> 04:46.363
这点比较费时

slide-9
04:48.560 --> 04:52.310
如果能提供一个官方的 muxer API，那就完美了

92
04:52.310 --> 04:56.460
这是我的建议。它可以跟随 WebCodecs 的设计

93-p
04:56.460 --> 04:59.280
这个 API 能为 Web 提供一些便利。首先，

94
04:59.280 --> 05:03.760
它能让浏览器媒体处理流程的蓝图变得完整

95
05:03.760 --> 05:06.750
如果我们希望一些视频格式得到推广应用

96
05:06.750 --> 05:10.572
例如 WebM, 我们理应尽量降低其生产难度

97-p
05:10.572 --> 05:14.500
对我而言最大的价值在于

98
05:14.500 --> 05:15.610
提供更好的编程体验

99
05:15.610 --> 05:18.970
FFmpeg 的源代码过于复杂，通常需要花大量时间

100
05:18.970 --> 05:23.200
去钻研其使用。这是我的分享内容

101
05:23.200 --> 05:24.983
谢谢观看
