<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Whatever can be done, will be done - Christoph Guttandin - W3C/SMPTE Joint Workshop on Professional Media Production on the Web</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../talk-ui.css">
    <link rel="stylesheet" href="https://www.w3.org/2019/09/TPAC-template/fonts/iconmonstr-iconic-font.css">
    <meta name="twitter:site" content="@w3c">
    <meta name="twitter:card" content="player">
    <meta property="og:title" content="Whatever can be done, will be done by Christoph Guttandin">
    <meta property="og:description" content="This talk presents a wishlist of common needs when developing media editing applications, along with relevant API features that could be used if they were supported across web browsers.">
    <meta property="og:image" content="thumbnails/christoph-guttandin-all-that-can-be-done.jpg">
    <meta property="og:video" content="https://iframe.videodelivery.net/4c7c3df9c8edb16f057c4c07027511ae">
    <meta property="twitter:player" content="https://iframe.videodelivery.net/4c7c3df9c8edb16f057c4c07027511ae?defaultTextTrack=en">
    <meta property="twitter:player:width" content="360">
    <meta property="twitter:player:height" content="202">
  </head>
  <body>
    <form id=form><!-- form to request a page in kiosk mode --></form>
    <header id="header" class="header">
      <div id="banner">
        <div>
          <p>
            <a href="https://www.w3.org/"><img alt="W3C" src=
            "../media/w3c_home_nb-v.svg" height="48" width="72"></a>
            <a href="https://www.smpte.org/"><img alt="SMPTE" src=
            "../media/smpte_logo.png" height="48"></a>
          </p>
          <div class="banner-title">
            <h1>
              W3C/SMPTE Joint Workshop on Professional Media Production on the Web
            </h1>
          </div>
          <p class="attribution">
            <span>Timeline photo by <a href="https://unsplash.com/@kineticbear?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Jacob Miller</a> on <a href="https://unsplash.com/s/photos/timeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>
          </p>
          <p>9-18 November 2021; online event</p>
        </div>
      </div>
      <nav class="menu" id="menu">
        <ul>
          <li>
            <a href="../">Call for Participation</a>
          </li>
          <li>
            <a href="../talks.html">Talks</a>
          </li>
          <li>
            <a href="../speakers.html">Apply as a speaker</a>
          </li>
        </ul>
      </nav>
    </header>
    <main id="main" class="main talk">
      <section id="intro">
        <h2>Whatever can be done, will be done</h2>

        <p class="talkinfo">
          Presenter: <strong>Christoph Guttandin</strong><br>
          Duration: <strong>14 minutes</strong><br>
          Slides: <a href="slides/christoph-guttandin-all-that-can-be-done.pdf"><strong>PDF</strong></a>
        </p>

        <p class="buttons">
          <!-- previousStart -->
          <button form="form" type="submit" class="picto im-angle-left" formaction="he-zhi-production-olympics.html">
            Previous: Live and post production for Sports Broadcasting
          </button>
          <!-- previousEnd -->
          <a href="../talks.html" class="picto im-data">All talks</a>
          <!-- nextStart -->
          <button form="form" type="submit" formaction="peter-salomonsen-webassembly-music.html">
            Next: WebAssembly Music - latency/stability across platforms <span class="picto im-angle-right"></span>
          </button>
          <!-- nextEnd -->
        </p>
      </section>

      <section id="talk">
        <h3 style="display:none">Slides &amp; video</h3>

        <details>
          <summary>Keyboard shortcuts in the video player</summary>
          <ul>
            <li>Play/pause: <kbd>space</kbd>
            </li><li>Increase volume: <kbd>up arrow</kbd>
            </li><li>Decrease volume: <kbd>down arrow</kbd>
            </li><li>Seek forward: <kbd>right arrow</kbd>
            </li><li>Seek backward: <kbd>left arrow</kbd>
            </li><li>Captions on/off: <kbd>C</kbd>
            </li><li>Fullscreen on/off: <kbd>F</kbd>
            </li><li>Mute/unmute: <kbd>M</kbd>
            </li><li>Seek to 0%, 10%… 90%: <kbd>0-9</kbd>
          </li></ul>
        </details>

        <div id="player">
          <script type="application/ld+json">
            {
              "@context": "https://schema.org",
              "@type": "VideoObject",
              "name": "Whatever can be done, will be done",
              "description": "This talk presents a wishlist of common needs when developing media editing applications, along with relevant API features that could be used if they were supported across web browsers.",
              "thumbnailUrl": "thumbnails/christoph-guttandin-all-that-can-be-done.jpg",
              "duration": "PT13M56S",
              "embedUrl": "https://iframe.videodelivery.net/4c7c3df9c8edb16f057c4c07027511ae",
            }
          </script>

          <iframe id="video" title="Whatever can be done, will be done" src="https://iframe.videodelivery.net/4c7c3df9c8edb16f057c4c07027511ae"
            allow="accelerometer; autoplay; encrypted-media; picture-in-picture"
            allowfullscreen="" width="640" height="360" frameborder="0"></iframe>

          <div id="slides" class="fade-in" role="region" aria-live="off" aria-label="Slide container">
            <div id="ts-1"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#1" class="slide">Slide 1 of 28</i-slide>
<div>
  <p id="tp-1">Hi everyone, thanks for having me. It’s a real pleasure to be a part of this workshop. </p>
  <p id="tp-2">I titled my talk Whatever can be done will be done". And I hope it becomes apparent in the end why I did so.</p>
</div>

</div><div id="ts-2"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#2" class="slide">Slide 2 of 28</i-slide>
<div>
  <p id="tp-3">I’m Christoph Guttandin. I have a company called Media Codings. And I do freelance work for various other companies and I guess the two most interesting in the context of this workshop are Source Elements and InVideo.</p>
  <p id="tp-4">I’m usually named chrisguttandin  anywhere on the internet. So in case you want to chat with me please feel free to reach out. Just send me a message on the platform of your choice.</p>
</div>

</div><div id="ts-3"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#3" class="slide">Slide 3 of 28</i-slide>
<div>
  <p id="tp-5">When I was asked to prepare a talk for this workshop I thought it’s a great opportunity to present our wishes to the world. So I asked my co-workers to help me preparing a list with the things that we would like to implement at some point or which we implemented already but would really like to implement in a better way if possible.</p>
</div>

</div><div id="ts-4"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#4" class="slide">Slide 4 of 28</i-slide>
<div>
  <p id="tp-6">The first item on our list is using custom codecs with WebRTC.</p>
</div>

</div><div id="ts-5"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#5" class="slide">Slide 5 of 28</i-slide>
<div>
  <p id="tp-7">Doing this has been possible for a while at least to a certain extent. You can do it by encoding the audio data and video data yourself. And then you would ignore the media functionality of WebRTC and send the data over a DataChannel. But the whole process is very cumbersome and at least for video it’s not very accurate as well. Every video frame needs to be drawn to a canvas and then it needs to be grabbed from there to hand it over to WebAssembly. It’s very likely that you miss a few frames when doing this with a live feed.</p>
</div>

</div><div id="ts-6"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#6" class="slide">Slide 6 of 28</i-slide>
<div>
  <p id="tp-8">Luckily this is not necessary anymore since we can now use WebCodecs to do this in a much more efficient way.</p>
  <p id="tp-9">But WebCodecs are only available in Chromium browsers  so far. Firefox is working on it. But unfortunately it’s unclear to me what Apple is thinking about it.</p>
</div>

</div><div id="ts-7"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#7" class="slide">Slide 7 of 28</i-slide>
<div>
  <p id="tp-10">The next item in our list is partial decoding.</p>
  <p id="tp-11">And with that we mean the ability to only decode  a certain range or maybe only one specific frame of a media asset.</p>
</div>

</div><div id="ts-8"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#8" class="slide">Slide 8 of 28</i-slide>
<div>
  <p id="tp-12">There is a very hacky way to do this for audio which works by using the decodeAudioData() method. This method is available on an AudioContext. Unfortunately it automatically re-samples the audio to the sampleRate of the AudioContext. That means the file needs to be parsed manually to know the correct sampleRate before doing the actual decoding. And decodeAudioData() only works with full files which is another reason why the file needs to be parsed before the decoding. We need to find out where it can be sliced. This is not that easy to figure out but it’s possible for most file types. And when done correctly and you’re lucky decodeAudioData() will happily decode a part of a file because it believes that it’s decoding the full file. </p>
  <p id="tp-13">Sadly though decodeAudioData() is really broken in the newest version of Safari. Apparently the bug is already fixed in the codebase. But no one knows when that fix will be available for Safari users.</p>
  <p id="tp-14">To decode a single video frame one could load the video  with a media element and then use seekToNextFrame() to get the frames one by one. </p>
  <p id="tp-15">But sadly this only works in Firefox.</p>
</div>

</div><div id="ts-9"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#9" class="slide">Slide 9 of 28</i-slide>
<div>
  <p id="tp-16">But again all of this is not necessary anymore now that we have WebCodecs support in Chromium and soon in Firefox.</p>
</div>

</div><div id="ts-10"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#10" class="slide">Slide 10 of 28</i-slide>
<div>
  <p id="tp-17">Another thing which is crucial for us is to offload as much as we can to other threads. In the end the main thread should just be there for triggering the work but not for doing it.</p>
</div>

</div><div id="ts-11"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#11" class="slide">Slide 11 of 28</i-slide>
<div>
  <p id="tp-18">There are a number of APIs which follow this pattern already. One of them is the AudioWorklet and the Web Audio API in general.</p>
  <p id="tp-19">For video content there is the OffscreenCanvas  which can be used from within a Web Worker.</p>
  <p id="tp-20">And last but not least it’s possible to insert  a TransformStream into a MediaStream and transfer that to a Web Worker as well.</p>
  <p id="tp-21">But as you can see browser support for anything  but the Web Audio API is not that great. Chromium supports all of those APIs. Firefox has an OffscreenCanvas implementation behind a flag but didn’t say anything about transferable streams so far. And as usual I don’t even dare to guess when this will be available in Webkit or Safari.</p>
</div>

</div><div id="ts-12"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#12" class="slide">Slide 12 of 28</i-slide>
<div>
  <p id="tp-22">Another thing which is often tricky for us is to keep media in sync.</p>
  <p id="tp-23">Especially if there is some audio or video  processing involved which will delay one or the other making sure audio and video appear to be sync again when played back becomes very tricky.</p>
</div>

</div><div id="ts-13"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#13" class="slide">Slide 13 of 28</i-slide>
<div>
  <p id="tp-24">There are two properties on an AudioContext which allow us to know when a sound scheduled on that AudioContext can actually be heard by the user. And this allows us to make sure the video frame displayed at that time matches the audio.</p>
  <p id="tp-25">But sadly these properties only fully work  in Firefox so far. I guess I don’t have to mention anymore for which browser I don’t know when they will be available or if they become available at all.</p>
</div>

</div><div id="ts-14"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#14" class="slide">Slide 14 of 28</i-slide>
<div>
  <p id="tp-26">Another hot topic for us is the possibility to select a certain output device instead of using the default one.</p>
</div>

</div><div id="ts-15"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#15" class="slide">Slide 15 of 28</i-slide>
<div>
  <p id="tp-27">There is a method one can call to change the output device of a media element but it only works in Chromium browsers so far. It’s called setSinkId().</p>
  <p id="tp-28">And as far as I know Firefox is currently implementing  the selectAudioOutput() method which is a new way to give consent to access audio output devices. And this is basically what blocks them from enabling setSinkId().</p>
  <p id="tp-29">Chromium browsers expose the audio output devices already.  Therefore implementing selectAudioOutput() is not really necessary to use setSinkId().</p>
  <p id="tp-30">But as usual I don’t have an idea what Apple is up to. </p>
</div>

</div><div id="ts-16"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#16" class="slide">Slide 16 of 28</i-slide>
<div>
  <p id="tp-31">So when looking at the wishlist again it looks like it became a todo list. All those things can be done now and existing hacks can be replaced with solid implementations, either today or in the near future.</p>
  <p id="tp-32">At least if we ignore Safari for now. </p>
  <p id="tp-33">Anyway, I came up with some more wishes  which aren’t really spec related anymore and are more geared towards the implementers.</p>
</div>

</div><div id="ts-17"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#17" class="slide">Slide 17 of 28</i-slide>
<div>
  <p id="tp-34">The first item on that list is that I wish for releases to be as boring as possible.</p>
  <p id="tp-35">I think Chromium browsers and Firefox do have  a pretty good process to ensure that already.</p>
</div>

</div><div id="ts-18"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#18" class="slide">Slide 18 of 28</i-slide>
<div>
  <p id="tp-36">Both browsers publish a nightly build. Right now this is version 97 for Chromium and 95 for Firefox. But the exact numbers don’t really matter here.</p>
  <p id="tp-37">Every 4 weeks the state of the nightly version  gets promoted to the next stage.</p>
</div>

</div><div id="ts-19"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#19" class="slide">Slide 19 of 28</i-slide>
<div>
  <p id="tp-38">Whatever has been the nightly version at that time becomes the beta version. Likewise the nightly version will increase as well. So it’s clear that whatever is in the nightly versions of those browsers today will be in beta in at least 4 weeks.</p>
</div>

</div><div id="ts-20"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#20" class="slide">Slide 20 of 28</i-slide>
<div>
  <p id="tp-39">Another 4 weeks later the beta version becomes the stable version and the nightly version - whatever that will be at that time - becomes the new beta version.</p>
  <p id="tp-40">It’s like a steady stream of updates.  And by the time a feature reaches the beta channel you can calculate the date at which it becomes available to all regular users.</p>
  <p id="tp-41">The whole process is very predictable  and yes it is super boring.</p>
  <p id="tp-42">I usually test my code against the nightly versions  to check regressions coming down the pipe and to make sure there will be no surprises (at least for me) when a new version of Chromium or Firefox gets published.</p>
</div>

</div><div id="ts-21"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#21" class="slide">Slide 21 of 28</i-slide>
<div>
  <p id="tp-43">Sadly things are a bit different with Safari. There is a Technology Preview of Safari which is currently at version 133. It contains a lot of experimental and unfinished implementations of upcoming features.</p>
  <p id="tp-44">But it is unknown which of those features end up  in the next stable release of Safari. They treat it as a secret. The Technology Preview and the stable Safari have completely unrelated version numbers. I guess the stable version is a subset of the Technology Preview but I can’t say that for sure.</p>
  <p id="tp-45">There is no way for developers to test their apps  with what becomes the next stable version of Safari. Testing it is only possible after it got already released to all the users.</p>
  <p id="tp-46">This is of course challenging when you try to build  a reliable web app that user’s can trust on to work as expected.</p>
  <p id="tp-47">Another problem is that the stable version of Safari  gets only updated every 6 months. Which means the minimum lifetime of regressions is usually 6 months. And since regressions can’t get caught before they get released, regressions are really not unheard of in Safari.</p>
  <p id="tp-48">As I said there is currently one which breaks  decodeAudioData() and another one which breaks audio streams in WebRTC.</p>
</div>

</div><div id="ts-22"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#22" class="slide">Slide 22 of 28</i-slide>
<div>
  <p id="tp-49">This leads me to my next wish.</p>
  <p id="tp-50">I would love regressions to get fixed as soon as possible. </p>
  <p id="tp-51">Imagine building a web app that media professionals  rely on to get their work done on every single day. And suddenly a browser update causes that app to fail.</p>
  <p id="tp-52">I know that even Safari can get security updates  in a very timely manner. And I would love that to happen for patches to fix regressions, too.</p>
</div>

</div><div id="ts-23"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#23" class="slide">Slide 23 of 28</i-slide>
<div>
  <p id="tp-53">I know some powerful features have the potential to get abused by malicious pages. And I definitely agree that certain features should not be enabled by default for each and every page.</p>
  <p id="tp-54">However I think the users of a browser  should have the option to allow certain sites to access the file system, to record the whole screen, to capture the system audio, to receive MIDI messages, to run high priority threads and so on and so on.</p>
  <p id="tp-55">I think this doesn’t need to be an explicit  permission prompt in every case. It could also be a little toast-style message that pops up to notify the users about the usage of a certain API or something totally different.</p>
  <p id="tp-56">The point is I think the users should be empowered  to decide themselves which features they want to enable and which ones they better don’t want to use right now.</p>
</div>

</div><div id="ts-24"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#24" class="slide">Slide 24 of 28</i-slide>
<div>
  <p id="tp-57">Similarly as a developer I would really love to have the same power. As I said before I like to run automated tests against the current and the upcoming version of each browser.</p>
  <p id="tp-58">I do this locally and I also do this in the cloud  with services like BrowserStack and Sauce Labs.</p>
  <p id="tp-59">It’s a real challenge to test media APIs  because they usually require user interaction to work. But there is obviously no user when running automated tests.</p>
  <p id="tp-60">There are flags that one can set for Chromium browsers  and Firefox. But they are not really very well documented and they always lag behind the capabilities of the browser and sadly they have the tendency to break from time to time.</p>
  <p id="tp-61">And at least as far as I know it’s not even possible  to disable the autoplay policy in Safari when starting the browser programmatically. That means things are more difficult to test in Safari. Which in turn means bugs get less caught. And this is of course a real problem since as I said before a typical bug stays in Safari for at least 6 months. But only if it gets caught in the first place.</p>
</div>

</div><div id="ts-25"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#25" class="slide">Slide 25 of 28</i-slide>
<div>
  <p id="tp-62">Another thing which is of course totally different but I think is a bit problematic as well is that building web apps seems to be so easy at first glance. Last week I saw a full WebCodecs example which fit on a single slide. That was very impressive and it showed that one could build something really powerful in no time.</p>
  <p id="tp-63">And yes, that’s absolutely true.  I did for example quickly hack together a little app to record this talk in the browser. (I didn’t use it in the end but that’s a different story.) But building a real web app which is meant to be used by people in a professional context day in and day out is a completely different story. Doing that requires a lot of effort. </p>
  <p id="tp-64">I think many people underestimate the amount of work that needs to be done to build a full product on the web.</p>
  <p id="tp-65">I honestly think building professional apps  is challenging in any environment and I wouldn’t expect to be easy on the web.</p>
</div>

</div><div id="ts-26"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#26" class="slide">Slide 26 of 28</i-slide>
<div>
  <p id="tp-66">But after all I think it’s mostly a chicken and egg problem. Once a few well known and well established web apps exist that have a wide adoption among media professionals others will become interested in bringing there apps to the web as well.</p>
  <p id="tp-67">Source Elements does for example have a plugin for DAWs.  It’s currently a native application since the DAWs that it’s meant to be used with are native applicationsas well. And this could only ever change if those DAWs become web apps at some point.</p>
  <p id="tp-68">There is definitely still a long way to go  but I think the shift has already begun.</p>
</div>

</div><div id="ts-27"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#27" class="slide">Slide 27 of 28</i-slide>
<div>
  <p id="tp-69">In conclusion I would like to repeat the title of this talk again: A fundamental rule in technology says whatever can be done will be done..</p>
  <p id="tp-70">I think building professional media applications  for the web is something that can be done today. And I know many people working on it. I hope and believe it’s only a matter of time until that becomes the new normal.</p>
</div>

</div><div id="ts-28"><i-slide src="slides/christoph-guttandin-all-that-can-be-done.pdf#28" class="slide">Slide 28 of 28</i-slide>
<div>
  <p id="tp-71">Thanks again to the people I work with for helping me to prepare this talk and many thanks to all of you for watching it. See you at the workshop. Bye.</p>
</div>

</div>
          </div>
        </div>
      </section>

      <section id="extrabuttons">
        <p class="buttons">
          <!-- previousStart -->
          <button form="form" id="prevtalk" type="submit" formaction="he-zhi-production-olympics.html" class="picto im-angle-left">Previous: Live and post production for Sports Broadcasting</button>
          <!-- previousEnd -->
          <a id="alltalks" href="../talks.html" class="picto im-data">All talks</a>
          <!-- nextStart -->
          <button form="form" id="nexttalk" type="submit" formaction="peter-salomonsen-webassembly-music.html">Next: WebAssembly Music - latency/stability across platforms <span class="picto im-angle-right"></span></button>
          <!-- nextEnd -->
        </p>
      </section>

      <section id="sponsors">
        <h2>
          Workshop sponsor
        </h2>
        <p><a href="https://www.adobe.com/"><img src="../media/adobe.png" alt="Adobe" width="70"></a></p>
        <p class="small">Interested in sponsoring the workshop?<br/>Please check the <a href="sponsors.html">sponsorship package</a>.</p>
      </section>
    </main>
    <footer class="footer" id="footer">
      <p>
        W3C is proud to be an open and inclusive organization, focused on
        productive discussions and actions. Our <a href=
        "https://www.w3.org/Consortium/cepc/">Code of Ethics and Professional
        Conduct</a> ensures that all voices can be heard.
      </p>
      <p>Questions? Contact François Daoust
        &lt;<a href="mailto:fd@w3.org">fd@w3.org</a>&gt;.
      </p>
      <p>
        Suggestions for improving this workshop page, such as fixing typos or
        adding specific topics, can be made by opening a <a href=
        "https://github.com/w3c/media-production-workshop/">pull request on
        GitHub</a>, or by emailing François Daoust
        &lt;<a href="mailto:fd@w3.org">fd@w3.org</a>&gt;.
      </p>
    </footer>
    <script src="../script.js"></script>
    <script>
      let captions = [
  {
    "language": "en",
    "label": "English",
    "src": "captions/christoph-guttandin-all-that-can-be-done.vtt",
    "mode": "hidden",
    "cues": [],
    "activeCues": [
      {
        "text": ""
      }
    ]
  }
];
    </script>
    <script src="https://www.w3.org/2019/09/TPAC-template/parser.js"></script>
    <script src="https://embed.videodelivery.net/embed/sdk.latest.js"></script>
    <script src="../talk-sync.js"></script>
    <script src="https://w3c.github.io/i-slide/i-slide.js" type="module"></script>
  </body>
</html>
