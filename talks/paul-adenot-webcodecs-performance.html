<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Memory access patterns in Web Codecs - Paul Adenot - W3C/SMPTE Joint Workshop on Professional Media Production on the Web</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../talk-ui.css">
    <link rel="stylesheet" href="https://www.w3.org/2019/09/TPAC-template/fonts/iconmonstr-iconic-font.css">
    <meta name="twitter:site" content="@w3c">
    <meta name="twitter:card" content="player">
    <meta property="og:title" content="Memory access patterns in Web Codecs by Paul Adenot (Mozilla)">
    <meta property="og:description" content="This talk discusses memory access patterns when WebCodecs is used in conjunction with other APIs, what WebCodecs does today to minimize memory access overhead, and envisioned solutions for further improvement in the near- and longer-term future so that WebCodecs&apos; performance profile can match that in a native application.">
    <meta property="og:image" content="thumbnails/paul-adenot-webcodecs-performance.jpg">
    <meta property="og:video" content="https://iframe.videodelivery.net/8e53aa9c27bfa9d8edb533996ca5d199">
    <meta property="twitter:player" content="https://iframe.videodelivery.net/8e53aa9c27bfa9d8edb533996ca5d199?defaultTextTrack=en">
    <meta property="twitter:player:width" content="360">
    <meta property="twitter:player:height" content="202">
  </head>
  <body>
    <form id=form><!-- form to request a page in kiosk mode --></form>
    <header id="header" class="header">
      <div id="banner">
        <div>
          <p>
            <a href="https://www.w3.org/"><img alt="W3C" src=
            "../media/w3c_home_nb-v.svg" height="48" width="72"></a>
            <a href="https://www.smpte.org/"><img alt="SMPTE" src=
            "../media/smpte_logo.png" height="48"></a>
          </p>
          <div class="banner-title">
            <h1>
              W3C/SMPTE Joint Workshop on Professional Media Production on the Web
            </h1>
          </div>
          <p class="attribution">
            <span>Timeline photo by <a href="https://unsplash.com/@kineticbear?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Jacob Miller</a> on <a href="https://unsplash.com/s/photos/timeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>
          </p>
          <p>9-18 November 2021; online event</p>
        </div>
      </div>
      <nav class="menu" id="menu">
        <ul>
          <li>
            <a href="../">Call for Participation</a>
          </li>
          <li>
            <a href="../talks.html">Talks</a>
          </li>
          <li>
            <a href="../speakers.html">Apply as a speaker</a>
          </li>
        </ul>
      </nav>
    </header>
    <main id="main" class="main talk">
      <section id="intro">
        <h2>Memory access patterns in Web Codecs</h2>

        <p class="talkinfo">
          Presenter: <strong>Paul Adenot (Mozilla)</strong><br>
          Duration: <strong>8 minutes</strong><br>
          Slides: <a href="slides/paul-adenot-webcodecs-performance/"><strong>HTML</strong></a> | <a href="slides/paul-adenot-webcodecs-performance.pdf"><strong>PDF</strong></a>
        </p>

        <p class="buttons">
          <!-- previousStart -->
          <button form="form" type="submit" class="picto im-angle-left" formaction="chris-cunningham-webcodecs-videoencoderconfig.html">
            Previous: WebCodecs VideoEncoderConfig
          </button>
          <!-- previousEnd -->
          <a href="../talks.html" class="picto im-data">All talks</a>
          <!-- nextStart -->
          <button form="form" type="submit" formaction="hongchan-choi-building-audio-apps.html">
            Next: Thoughts and considerations on building audio apps on the web<span class="picto im-angle-right"></span>
          </button>
          <!-- nextEnd -->
        </p>
      </section>

      <section id="talk">
        <h3 style="display:none">Slides &amp; video</h3>

        <details>
          <summary>Keyboard shortcuts in the video player</summary>
          <ul>
            <li>Play/pause: <kbd>space</kbd>
            </li><li>Increase volume: <kbd>up arrow</kbd>
            </li><li>Decrease volume: <kbd>down arrow</kbd>
            </li><li>Seek forward: <kbd>right arrow</kbd>
            </li><li>Seek backward: <kbd>left arrow</kbd>
            </li><li>Captions on/off: <kbd>C</kbd>
            </li><li>Fullscreen on/off: <kbd>F</kbd>
            </li><li>Mute/unmute: <kbd>M</kbd>
            </li><li>Seek to 0%, 10%… 90%: <kbd>0-9</kbd>
          </li></ul>
        </details>

        <div id="player">
          <script type="application/ld+json">
            {
              "@context": "https://schema.org",
              "@type": "VideoObject",
              "name": "Memory access patterns in Web Codecs",
              "description": "This talk discusses memory access patterns when WebCodecs is used in conjunction with other APIs, what WebCodecs does today to minimize memory access overhead, and envisioned solutions for further improvement in the near- and longer-term future so that WebCodecs' performance profile can match that in a native application.",
              "thumbnailUrl": "thumbnails/paul-adenot-webcodecs-performance.jpg",
              "duration": "PT7M31S",
              "embedUrl": "https://iframe.videodelivery.net/8e53aa9c27bfa9d8edb533996ca5d199",
            }
          </script>

          <iframe id="video" title="Memory access patterns in Web Codecs" src="https://iframe.videodelivery.net/8e53aa9c27bfa9d8edb533996ca5d199"
            allow="accelerometer; autoplay; encrypted-media; picture-in-picture"
            allowfullscreen="" width="640" height="360" frameborder="0"></iframe>

          
    <div class="related">
      <p>Related conversations on <a href="https://github.com/w3c/media-production-workshop/issues">GitHub</a>:</p>
      <ul>
        <li><a href="https://github.com/w3c/media-production-workshop/issues/30">Avoiding memory copies in media production workflows</a> (#30)</li>
        <li><a href="https://github.com/w3c/media-production-workshop/issues/59">Advanced use cases for WebCodecs</a> (#59)</li>
      </ul>
    </div>

          <div id="slides" class="fade-in" role="region" aria-live="off" aria-label="Slide container">
            <div id="ts-1"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#1" class="slide">Slide 1 of 12</i-slide>
<div>
  <p id="tp-1">Hi, my name is Paul Adenot. I work at Mozilla on anything related to audio and video in Firefox.</p>
  <p id="tp-2">Today, I'd like to talk about a recent API called the WebCodecs API. And in particular about memory access patterns when using this API in conjunction with other APIs on the web platform. We'll talk about some raw performance numbers when accessing video frames, what WebCodecs does today to minimize memory, access overhead and some problems that the API has today, where a solution exists, but hasn't been implemented. And more importantly about a couple of harder problems that we'll tackle in the future, so that using WebCodecs will have the same performance profile as a native app.</p>
  <p id="tp-3">Before starting, I'd like to say that any simple scenario, such as decoding and rendering video and audio are fairly optimized today, and we'll be talking about advanced use cases, such as big native apps compiled to WebAssembly that leverage WebCodecs to speed up their encoding and decoding operations or other programs that are making a rather intensive use WebCodecs and want to minimize any inefficiencies.</p>
</div>

</div><div id="ts-2"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#2" class="slide">Slide 2 of 12</i-slide>
<div>
  <p id="tp-4">But first let me repeat an old quote often heard in the free software multimedia development circles: memcpy is murder". Behind this tongue-in-cheek sentence lies in important fact: to maximize performance, the minimum of memory copies need to happen. And the working set of an app needs to be as small as possible to ideally fit into CPU caches. Fetching memory into caches is slow, caches are small, so no duplication should happen.</p>
</div>

</div><div id="ts-3"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#3" class="slide">Slide 3 of 12</i-slide>
<div>
  <p id="tp-5">But first let's consider the size of the problem.</p>
  <p id="tp-6">A video frame in YUV420, full HD, standard dynamic range is around 4MB. A video frame in YUV420, 4K, standard dynamic range is around 16MB. A video frame in P010, full HD, high dynamic range, (either 10 or 12 bits) is around 32MB.</p>
</div>

</div><div id="ts-4"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#4" class="slide">Slide 4 of 12</i-slide>
<div>
  <p id="tp-7">Here are some performance numbers that I've gathered, writing a small C++ program on my extremely high-end Linux workstation, of copying a single frame of this size. A video frame in YUV420, full HD, standard dynamic range, takes about 1.5ms to copy when the cache is hot, which means the source is already in the cache. And 4.5ms if not. The source needs to be fetched from memory. Two frames easily fit in the cache of this CPU.</p>
  <p id="tp-8">A video frame in YUV 420, 4K, standard dynamic range, takes 6.6ms and 17ms when in CPU cache. This only works because the CPU I'm running on has lots of cache, and a single frame still fits.</p>
  <p id="tp-9">A video frame in P010, full HD, high dynamic range either 10 or 12 bits, takes 15ms if the caches are hot and 33ms if not. The CPU I'm running this on has 20MB of L3 cache, so only a partial frame fits.</p>
  <p id="tp-10">Considering the budget for a single frame at 30Hz is 33ms and 16.6ms at 60Hz, we can quickly see that the numbers here are uncomfortable, and minimizing memory copies are going to be of importance. I'll repeat that standard scenarios in WebCodecs such as playback don't make copies. I'm talking about advanced use cases here, such as processing.</p>
</div>

</div><div id="ts-5"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#5" class="slide">Slide 5 of 12</i-slide>
<div>
  <p id="tp-11">Additionally, GPU to CPU copies (read back) and CPU to GPU copies (texture uploads) are also quite expensive. It's best to carefully consider when and how they need to be done, and to try to minimize transfers, if possible. WebCodecs has been carefully designed to allow to easily leave VideoFrames on the GPU and makes all copies explicit.</p>
</div>

</div><div id="ts-6"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#6" class="slide">Slide 6 of 12</i-slide>
<div>
  <p id="tp-12">But sometimes it really is necessary to perform copies. Here are three scenarios when this is unavoidable.</p>
  <p id="tp-13">Custom processing of video frames that are on the GPU using regular JavaScript or WASM code in which case we need to read back.</p>
  <p id="tp-14">Custom processing of video frames that are on the CPU via WASM, then the data needs to be copied into the WASM heap, or working with other web API that requires copies.</p>
  <p id="tp-15">For example, playing audio data with an AudioWorklet will require copying into the AudioWorklet output buffer.</p>
</div>

</div><div id="ts-7"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#7" class="slide">Slide 7 of 12</i-slide>
<div>
  <p id="tp-16">As said, WebCodecs has been designed with copy minimization in mind. The memory is not visible directly to script, and authors need to call a function called copyTo" to get an ArrayBuffer that can be directly manipulated. This copyTo" method can also take care of conversion in certain cases. when calling clone on a VideoFrame or AudioData object, the underlying resources are referenced for a second time, instead of copied, so a single frame can be used in different context efficiently. Doing a deep copy is still possible.</p>
  <p id="tp-17">Now, let's see a number of copies that exist today in WebCodecs.</p>
  <p id="tp-18">First, the compressed input of a decoder is currently copied. This is not that problematic because the input is a lot smaller than the output. It could be optimized.</p>
  <p id="tp-19">More importantly, there is currently no way to become the owner of the memory behind a VideoFrame or an AudioData, when it's regular memory, non GPU.</p>
  <p id="tp-20">Finally, the API for now does a lot of allocations and deallocation, thrashing CPU caches unnecessarily.</p>
</div>

</div><div id="ts-8"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#8" class="slide">Slide 8 of 12</i-slide>
<div>
  <p id="tp-21">Here are two simple design proposals to fix the two last points in this list.</p>
</div>

</div><div id="ts-9"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#9" class="slide">Slide 9 of 12</i-slide>
<div>
  <p id="tp-22">First, a method called detach" could return an ArrayBuffer and close the video frame in one call, skipping a copy when possible, for example, when it hasn't been closed, that's fairly common. Similarly, we can add this method on AudioData.</p>
</div>

</div><div id="ts-10"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#10" class="slide">Slide 10 of 12</i-slide>
<div>
  <p id="tp-23">Next, we can limit the native allocation and deallocation pressure by taking a buffer in the decode method, in which the decoded data is going to be written to, and getting back the input buffer to reuse, in the output callback. This will matter a lot for audio where it's a lot easier for buffer to fit in CPU caches, but their numbers are a lot bigger.</p>
</div>

</div><div id="ts-11"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#11" class="slide">Slide 11 of 12</i-slide>
<div>
  <p id="tp-24">Now let's talk about some of the harder problems faced on the web platform today.</p>
  <p id="tp-25">First, the necessity to copy from and to the WASM heap becomes problematic when the data to copy is big enough, such as video frames. Decoding into the WASM heap would be a welcome feature, but this needs some work.</p>
  <p id="tp-26">Then there is a problem of passing views over SharedArrayBuffer to APIs. SharedArrayBuffer is often a good solution to limit copies, but it's often unclear what those API do to memory and if they work with concurrent writes to the memory region that has been passed to them. Having read-only memory ranges on SharedArrayBuffer, could be a solution here, but it's a complex problem.</p>
  <p id="tp-27">An effort has been started to try to document the problems about copies on the platform at the WICG, and I encourage interested parties to voice their opinions and contribute their experience to the discussion, reports from the field are always welcomed and very important to inform future developments.</p>
</div>

</div><div id="ts-12"><i-slide src="slides/paul-adenot-webcodecs-performance.pdf#12" class="slide">Slide 12 of 12</i-slide>
<div>
  <p id="tp-28">In conclusion, while WebCodecs can and will be improved when it comes to memory access, it's already extremely powerful and common use cases are already quite fast. Making it perfect is certainly possible and will probably happen in the future. Thanks.</p>
</div>

</div>
          </div>
        </div>
      </section>

      <section id="extrabuttons">
        <p class="buttons">
          <!-- previousStart -->
          <button form="form" id="prevtalk" type="submit" formaction="chris-cunningham-webcodecs-videoencoderconfig.html" class="picto im-angle-left">Previous: WebCodecs VideoEncoderConfig</button>
          <!-- previousEnd -->
          <a id="alltalks" href="../talks.html" class="picto im-data">All talks</a>
          <!-- nextStart -->
          <button form="form" id="nexttalk" type="submit" formaction="hongchan-choi-building-audio-apps.html">Next: Thoughts and considerations on building audio apps on the web<span class="picto im-angle-right"></span></button>
          <!-- nextEnd -->
        </p>
      </section>

      <section id="sponsors">
        <h2>
          Workshop sponsor
        </h2>
        <p><a href="https://www.adobe.com/"><img src="../media/adobe.png" alt="Adobe" width="70"></a></p>
        <p class="small">Interested in sponsoring the workshop?<br/>Please check the <a href="sponsors.html">sponsorship package</a>.</p>
      </section>
    </main>
    <footer class="footer" id="footer">
      <p>
        W3C is proud to be an open and inclusive organization, focused on
        productive discussions and actions. Our <a href=
        "https://www.w3.org/Consortium/cepc/">Code of Ethics and Professional
        Conduct</a> ensures that all voices can be heard.
      </p>
      <p>Questions? Contact François Daoust
        &lt;<a href="mailto:fd@w3.org">fd@w3.org</a>&gt;.
      </p>
      <p>
        Suggestions for improving this workshop page, such as fixing typos or
        adding specific topics, can be made by opening a <a href=
        "https://github.com/w3c/media-production-workshop/">pull request on
        GitHub</a>, or by emailing François Daoust
        &lt;<a href="mailto:fd@w3.org">fd@w3.org</a>&gt;.
      </p>
    </footer>
    <script src="../script.js"></script>
    <script>
      let captions = [
  {
    "language": "en",
    "label": "English",
    "src": "captions/paul-adenot-webcodecs-performance.vtt",
    "mode": "hidden",
    "cues": [],
    "activeCues": [
      {
        "text": ""
      }
    ]
  }
];
    </script>
    <script src="https://www.w3.org/2019/09/TPAC-template/parser.js"></script>
    <script src="https://embed.videodelivery.net/embed/sdk.latest.js"></script>
    <script src="../talk-sync.js"></script>
    <script src="https://w3c.github.io/i-slide/i-slide.js" type="module"></script>
  </body>
</html>
